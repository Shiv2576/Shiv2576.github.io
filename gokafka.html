<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GO + Kafka Documentation</title>
        <style>
            :root {
                --bg-dark: #000000;
                --text-dark: #f8f5f0;
                --bg-light: #ffffff;
                --text-light: #121212;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background-color: var(--bg-dark);
                color: var(--text-dark);
                font-family: "Chivo Mono", "Courier New", monospace;
                font-size: 18px;
                line-height: 28px;
                padding: 4rem 10%;
                transition:
                    background-color 0.4s,
                    color 0.4s;
            }

            body.light-mode {
                background-color: var(--bg-light);
                color: var(--text-light);
            }

            .mode-toggle {
                position: fixed;
                top: 2rem;
                right: 2rem;
                background: transparent;
                border: 1px solid currentColor;
                color: inherit;
                padding: 0.4rem 0.8rem;
                font-family: inherit;
                font-size: 14px;
                cursor: pointer;
                z-index: 10;
            }

            h1.chapter {
                font-size: 2.4rem;
                margin: 4rem 0 2rem;
                font-weight: 400;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            h1.chapter svg {
                width: 24px;
                height: 24px;
                fill: currentColor;
            }

            h2.section {
                font-size: 1.6rem;
                margin: 3rem 0 1.5rem;
                font-weight: 400;
                color: inherit;
            }

            h2.section a {
                color: inherit;
                text-decoration: none;
            }

            h2.section a:hover {
                text-decoration: underline;
            }

            p {
                margin: 0 0 16px;
            }

            @media (max-width: 768px) {
                body {
                    padding: 3rem 6%;
                }
            }
        </style>
    </head>
    <body class="dark-mode">
        <button class="mode-toggle" id="modeToggle">Light Mode</button>

        <h1 class="chapter">
            <a
                href="https://github.com/Shiv2576/Go-Kafka-Learning-Documentation-Roadmap"
                target="_blank"
                rel="noopener"
                style="
                    color: inherit;
                    text-decoration: none;
                    display: inline-flex;
                    align-items: center;
                    gap: 12px;
                "
            >
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path
                        d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.603-.015 2.898-.015 3.293 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"
                    />
                </svg>
                Go + Kafka Documentation
            </a>
        </h1>

        <h2 class="section" id="1-setup--basics">
            <a href="">1. Setup & Basics</a>
        </h2>
        <p>
            Begin by installing Kafka locally, with Docker being the most
            straightforward approach. Install a Go Kafka client such as
            confluent-kafka-go cli . Create a “Hello Kafka” application
            consisting of a producer that sends a simple string like “Hello
            World” to a topic and a consumer that reads from that same topic and
            prints the message. Document the steps taken to install Kafka,
            include the first working producer and consumer implementation in
            narrative form, and provide logs or terminal output that confirm
            successful message flow.
        </p>

        <h2 class="section" id="2-topics-partitions--consumer-groups">
            <a href="#2-topics-partitions--consumer-groups"
                >2. Topics, Partitions & Consumer Groups</a
            >
        </h2>
        <p>
            Create multiple topics such as orders and payments. Add partitions
            to a topic to enable parallelism. Run several consumers within the
            same consumer group and observe how Kafka automatically balances
            partitions among them. Then, run multiple consumer groups reading
            from the same topic to demonstrate independent consumption with
            separate offset tracking. Document the conceptual meaning of topics
            as message streams, partitions as ordered segments, offsets as read
            positions, and consumer groups as cooperative units. Include simple
            diagrams that illustrate how messages flow and how partitions are
            assigned.
        </p>

        <h2 class="section" id="3-message-patterns">
            <a href="#3-message-patterns">3. Message Patterns</a>
        </h2>
        <p>
            Work with structured data using formats like JSON, Avro, or
            Protobuf. Assign keys to messages and observe how Kafka uses those
            keys to route messages to specific partitions. Explore Kafka’s
            ordering guarantees—messages with the same key are always written to
            the same partition, ensuring order within that key’s stream, though
            not across the entire topic. Document why keys are essential for
            semantic routing and consistent processing, and note the common
            misunderstanding that ordering applies globally rather than per
            partition.
        </p>

        <h2 class="section" id="4-stream-processing-concepts">
            <a href="#4-stream-processing-concepts"
                >4. Stream Processing Concepts</a
            >
        </h2>
        <p>
            Implement basic stream processing operations directly in Go. Build
            consumers that filter messages based on field values, transform or
            enrich payloads before writing them to new topics, and support
            fan-out patterns where one topic feeds multiple downstream
            consumers. While the Kafka Streams API is Java-only, map its core
            ideas—such as stateless transformations and topic chaining—to Go’s
            concurrency model. Document these patterns through descriptive
            examples and diagrams showing the flow from source topic through
            processing logic to output topic.
        </p>

        <h2 class="section" id="5-scaling--deployment">
            <a href="#5-scaling--deployment">5. Scaling & Deployment</a>
        </h2>
        <p>
            Run Kafka using Docker Compose, optionally in KRaft mode to
            eliminate ZooKeeper. Deploy multiple instances of producers and
            consumers to simulate real-world conditions. Test system behavior
            under load by flooding the topic with messages and observing how
            consumers handle backpressure. Introduce manual offset commits to
            understand the balance between performance and delivery guarantees.
            Document the Docker Compose configuration, describe how offset
            management affects replay and fault tolerance, and share lessons
            learned about scaling consumer fleets.
        </p>

        <h2 class="section" id="6-advanced-kafka-features">
            <a href="#6-advanced-kafka-features">6. Advanced Kafka Features</a>
        </h2>
        <p>
            Explore Kafka’s advanced capabilities including retention policies
            that expire old data and log compaction that retains the latest
            value per key. With the Confluent client, implement exactly-once
            semantics using transactions and idempotent producers. Design
            error-handling strategies such as Dead Letter Queues for messages
            that fail repeatedly. Document the practical tradeoffs between
            at-most-once, at-least-once, and exactly-once delivery models, and
            reference key configuration parameters related to retention and
            compaction without presenting them as raw code.
        </p>

        <h2 class="section" id="7-real-project--capstone">
            <a href="#7-real-project--capstone">7. Real Project / Capstone</a>
        </h2>
        <p>
            Conclude the journey with a capstone project such as an order
            processing pipeline, a real-time chat application, or a trade
            matching system. Structure it so that event sources act as
            producers, Kafka serves as the central event backbone, and multiple
            services consume and react to streams. Deploy the system using
            Docker Compose or Kubernetes. Document the full implementation in a
            public repository, including an architecture diagram and reflective
            commentary on what worked well, what failed, and what architectural
            tradeoffs were made throughout development.
        </p>

        <script>
            const btn = document.getElementById("modeToggle");
            const body = document.body;

            const saved = localStorage.getItem("theme");
            if (saved === "light") {
                body.classList.add("light-mode");
                btn.textContent = "Dark Mode";
            }

            btn.addEventListener("click", () => {
                if (body.classList.contains("light-mode")) {
                    body.classList.remove("light-mode");
                    btn.textContent = "Light Mode";
                    localStorage.setItem("theme", "dark");
                } else {
                    body.classList.add("light-mode");
                    btn.textContent = "Dark Mode";
                    localStorage.setItem("theme", "light");
                }
            });
        </script>
    </body>
</html>
